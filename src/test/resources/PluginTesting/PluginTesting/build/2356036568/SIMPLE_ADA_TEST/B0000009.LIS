
               with  DATABASE;
               with  TYPES; use TYPES;
               package  body MANAGER is

                   MAX_NAME_LENGTH : constant := 20;
                   subtype WAITING_LIST_NAME_TYPE is string(1..MAX_NAME_LENGTH);
                   type WAITING_LIST_TYPE;
                   type WAITING_LIST_TYPE_PTR is access WAITING_LIST_TYPE;
                   type WAITING_LIST_TYPE is
                      record
                         NAME : WAITING_LIST_NAME_TYPE := ( others => ' ' );
                         NEXT : WAITING_LIST_TYPE_PTR := null;
                      end record;
                   WAITING_LIST : WAITING_LIST_TYPE_PTR := null;
               procedure  PLACE_ORDER (
                      TABLE : in     TYPES.TABLE_INDEX_TYPE;
                      SEAT  : in     TYPES.SEAT_INDEX_TYPE;
                      ORDER : in out TYPES.ORDER_TYPE) is


                   TABLE_DATA : TYPES.TABLE_DATA_TYPE;

1 0     ( )        begin

1 1                   DATABASE.GET_TABLE_RECORD (
                         TABLE => TABLE,
                         DATA  => TABLE_DATA);

1 2                   TABLE_DATA.IS_OCCUPIED := true;
1 3                   TABLE_DATA.NUMBER_IN_PARTY := TABLE_DATA.NUMBER_IN_PARTY + 1;
1 4                   TABLE_DATA.ORDER (SEAT) := ORDER;

1 5                   ADD_INCLUDED_DESSERT ( TABLE_DATA.ORDER(SEAT) );

1 6                   case ORDER.ENTREE is
1 7     ( )           when TYPES.NO_ORDER =>
1 8                      null;
1 9     ( )           when TYPES.STEAK =>
1 10                     TABLE_DATA.CHECK_TOTAL := TABLE_DATA.CHECK_TOTAL + 14;
1 11    ( )           when TYPES.CHICKEN =>
1 12                     TABLE_DATA.CHECK_TOTAL := TABLE_DATA.CHECK_TOTAL + 10;
1 13    ( )           when TYPES.LOBSTER =>
1 14                     TABLE_DATA.CHECK_TOTAL := TABLE_DATA.CHECK_TOTAL + 18;
1 15    ( )           when TYPES.PASTA =>
1 16                     TABLE_DATA.CHECK_TOTAL := TABLE_DATA.CHECK_TOTAL + 12;
                      end case;

1 18                  DATABASE.UPDATE_TABLE_RECORD (
                         TABLE => TABLE,
                         DATA  => TABLE_DATA);
               end  PLACE_ORDER;
               procedure  ADD_INCLUDED_DESSERT ( ORDER : in out TYPES.ORDER_TYPE ) is

2 0     ( )        begin
2 1     ( )( )        if ORDER.ENTREE   = STEAK and
                         ORDER.SALAD    = CAESAR and
                         ORDER.BEVERAGE = MIXED_DRINK
                      then
2 2                      ORDER.DESSERT := PIE;
2 3     ( )( )        elsif ORDER.ENTREE   = LOBSTER and
                            ORDER.SALAD    = GREEN and
                            ORDER.BEVERAGE = WINE
                      then
2 4                      ORDER.DESSERT := CAKE;
                      end if;
               end  ADD_INCLUDED_DESSERT;
               procedure  CLEAR_TABLE (
                      TABLE : in     TYPES.TABLE_INDEX_TYPE) is


                   TABLE_DATA : TYPES.TABLE_DATA_TYPE;
                   NULL_ORDER : TYPES.ORDER_TYPE :=
                      (SOUP      => TYPES.NO_ORDER,
                       SALAD     => TYPES.NO_ORDER,
                       ENTREE    => TYPES.NO_ORDER,
                       DESSERT   => TYPES.NO_ORDER,
                       BEVERAGE  => TYPES.NO_ORDER);

3 0     ( )        begin

3 1                   DATABASE.GET_TABLE_RECORD (
                         TABLE => TABLE,
                         DATA  => TABLE_DATA);

3 2                   TABLE_DATA.IS_OCCUPIED := false;
3 3                   TABLE_DATA.NUMBER_IN_PARTY := 1;
3 4     ( )( )        for SEAT in TYPES.SEAT_INDEX_TYPE loop
3 5                      TABLE_DATA.ORDER (SEAT) := NULL_ORDER;
                      end loop;
3 7                   TABLE_DATA.CHECK_TOTAL := 0;

3 8                   DATABASE.UPDATE_TABLE_RECORD (
                         TABLE => TABLE,
                         DATA  => TABLE_DATA);
               end  CLEAR_TABLE;
               function  GET_CHECK_TOTAL (TABLE : TYPES.TABLE_INDEX_TYPE)
                      return integer is


                   TABLE_DATA : TYPES.TABLE_DATA_TYPE;

4 0     ( )        begin

4 1                   DATABASE.GET_TABLE_RECORD (
                         TABLE => TABLE,
                         DATA  => TABLE_DATA);

4 2                   return TABLE_DATA.CHECK_TOTAL;
               end  GET_CHECK_TOTAL;
               procedure  ADD_PARTY_TO_WAITING_LIST ( NAME : in     string ) is

                      TO_ADD : WAITING_LIST_TYPE_PTR := new WAITING_LIST_TYPE;
5 0     ( )        begin
5 1     ( )( )        if NAME'length > MAX_NAME_LENGTH then
5 2                      TO_ADD.NAME := NAME(NAME'first..NAME'first+MAX_NAME_LENGTH-1);
                      else
5 4                      TO_ADD.NAME(1..NAME'length) := NAME;
                      end if;
5 6                   TO_ADD.NEXT := WAITING_LIST;
5 7                   WAITING_LIST := TO_ADD;
               end  ADD_PARTY_TO_WAITING_LIST;
               function  GET_NEXT_PARTY_TO_BE_SEATED return string is

                      PTR : WAITING_LIST_TYPE_PTR := WAITING_LIST;
                      RET : WAITING_LIST_NAME_TYPE := ( others => ' ' );
6 0     ( )        begin
6 1     ( )( )        if PTR = null then
6 2                      null;
6 3     ( )( )        elsif PTR.NEXT = null then
6 4                      RET := PTR.NAME;
6 5                      WAITING_LIST := null;
                      else
6 7     ( )( )           while PTR.NEXT.NEXT /= null loop
6 8                         PTR := PTR.NEXT;
                         end loop;
6 10                     RET := PTR.NEXT.NAME;
6 11                     PTR.NEXT := null;
                      end if;
6 13    ( )( )        for IDX in reverse 1 .. RET'length loop
6 14    ( )( )           if RET(IDX) /= ' ' then
6 15                        return RET(1..IDX);
                         end if;
                      end loop;
6 18                  return "";
               end  GET_NEXT_PARTY_TO_BE_SEATED;
               function  "-" (X : in integer; Y : in integer)
                      return integer is

7 0     ( )        begin
7 1     ( )( )      if X > 0 then
7 2                   return X;
                    else
7 4                   return Y;
                    end if;
               end  "-";
               function  "&" (X : in integer; Y : in integer)
                      return integer is

8 0     ( )        begin
8 1     ( )( )      if X > 0 then
8 2                   return X;
                    else
8 4                   return Y;
                    end if;
               end  "&";
               end  MANAGER;
